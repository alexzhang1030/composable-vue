# Composition vs Options

Vue3 和 Vue2 有什么本质上的区别？

大部分人肯定会想到，Vue3 引入了 Composition API，这是一个破坏性改动，这标志着 Vue3 不再向后兼容 Vue2。但最重要的是整个心智模型已经发生了变化。

## Vue2

探究其源，Vue2 是如何运行起来的？

```vue
<script>
export default {
  data() {
    return {
      vue2: 'vue2'
    }
  },
  methods: {
    foo() {
      return 'vue2'
    }
  }
}
</script>

<template>
  {{ vue2 }}
</template>
```

响应式是如何绑定起来的？

首先，SFC 会被编译为类似这样：

```js
const App = {
  data() {
    return {
      vue2: 'vue2'
    }
  },
  methods: {
    foo() {
      return 'vue2'
    }
  },
  render() {
    return h('div', {}, this.vue2)
  }
}
```

在 Vue2 内部的初始化组件过程中，为组件初始化一个 [`Observer`](https://github.com/vuejs/vue/blob/a9ca2d85193e435e668ba25ace481bfb176b0c6e/src/core/observer/index.ts#L48) 实例。


在初始化的 `Observer` 过程中，会为 data 中[每一个值](https://github.com/vuejs/vue/blob/a9ca2d85193e435e668ba25ace481bfb176b0c6e/src/core/observer/index.ts#L80-L82)执行一次 [`defineReactive`](https://github.com/vuejs/vue/blob/a9ca2d85193e435e668ba25ace481bfb176b0c6e/src/core/observer/index.ts#L128)

简化一下：

```js
export function defineReactive(obj, key, val) {
  const dep = new Dep()
  // 拿到属性描述符
  const property = Object.getOwnPropertyDescriptor(obj, key)
  // 如果 configurable 是 false，即不对其进行响应式处理
  if (property && property.configurable === false)
    return
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      const value = getter ? getter.call(obj) : val
      if (Dep.target)
        dep.depend()
      return value
    },
    set: function reactiveSetter(newVal) {
      const value = getter ? getter.call(obj) : val
      if (!hasChanged(value, newVal))
        return
      if (setter)
        setter.call(obj, newVal)
      else
        val = newVal
      dep.notify()
    }
  })
}
```

首先会创建一个 `Dep` 绑定当前值，然后会通过 `Object.defineProperty` 为每一个属性设置 getter 和 setter。在 `getter` 时，调用 `Dep.depend`，在 `setter` 时，调用 `Dep.notify`。每一个值会单独去维护它的依赖关系，并在值发生变化时通知并触发依赖更新。

但是由于 Vue2 的实现以及 `Object.defineProperty` 的缺陷，Vue2 无法监听到数组的变化。所以 Vue2 会在初始化的时候，对数组进行一次[特殊处理](https://github.com/vuejs/vue/blob/a9ca2d85193e435e668ba25ace481bfb176b0c6e/src/core/observer/index.ts#L171-L173)。但如果原本 `data` 中不存在的值，需要更新的话，就需要用 [`$set`](https://github.com/vuejs/vue/blob/a9ca2d85193e435e668ba25ace481bfb176b0c6e/src/core/instance/state.ts#L362) 去做响应式处理。

所以在 Vue2 中，复用逻辑一直是一个问题(`Mixin` 与本题不符，故不提），任何复用逻辑都必须通过组件实例自己去处理响应式值的关系。同时由于 Vue2 只能在 `methods` 中向模板暴露方法，所以 hooks 在 Vue2 中就显得非常奇怪：

```js
import { useModal } from './boolean'
const { isShow, openModal } = useModal()
export default {
  data() {
    return {
      isShow,
    }
  },
  methods: {
    openModal() {
      this.isShow = true
      openModal({ /* params */ })
    }
  }
}
```

像这种半复用半不复用的逻辑，我们没办法在 Hooks 中使用响应式变量，故而就需要在每个用的到的组件中做冗余的处理，即——**将 hooks 与当前组件的响应式变量关联起来**。